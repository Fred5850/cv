import{a as K,c as ke}from"./chunk-NWJ5J3BN.js";var n={allRenderFn:!1,cmpDidLoad:!0,cmpDidUnload:!1,cmpDidUpdate:!0,cmpDidRender:!0,cmpWillLoad:!0,cmpWillUpdate:!0,cmpWillRender:!0,connectedCallback:!0,disconnectedCallback:!0,element:!0,event:!0,hasRenderFn:!0,lifecycle:!0,hostListener:!0,hostListenerTargetWindow:!0,hostListenerTargetDocument:!0,hostListenerTargetBody:!0,hostListenerTargetParent:!1,hostListenerTarget:!0,member:!0,method:!0,mode:!0,observeAttribute:!0,prop:!0,propMutable:!0,reflect:!0,scoped:!0,shadowDom:!0,slot:!0,cssAnnotations:!0,state:!0,style:!0,formAssociated:!1,svg:!0,updatable:!0,vdomAttribute:!0,vdomXlink:!0,vdomClass:!0,vdomFunctional:!0,vdomKey:!0,vdomListener:!0,vdomRef:!0,vdomPropOrAttr:!0,vdomRender:!0,vdomStyle:!0,vdomText:!0,watchCallback:!0,taskQueue:!0,hotModuleReplacement:!1,isDebug:!1,isDev:!1,isTesting:!1,hydrateServerSide:!1,hydrateClientSide:!1,lifecycleDOMEvents:!1,lazyLoad:!1,profile:!1,slotRelocation:!0,appendChildSlotFix:!1,cloneNodeFix:!1,hydratedAttribute:!1,hydratedClass:!0,scriptDataOpts:!1,scopedSlotTextContentFix:!1,shadowDomShim:!1,slotChildNodesFix:!1,invisiblePrehydration:!0,propBoolean:!0,propNumber:!0,propString:!0,constructableCSS:!0,cmpShouldUpdate:!0,devTools:!1,shadowDelegatesFocus:!0,initializeNextTick:!1,asyncLoading:!0,asyncQueue:!1,transformTagName:!1,attachStyles:!0,experimentalSlotFixes:!1};var G="app";var Dt=ke({});var Tt=Object.defineProperty,It=(e,t)=>{for(var s in t)Tt(e,s,{get:t[s],enumerable:!0})},Ee={isDev:!!n.isDev,isBrowser:!0,isServer:!1,isTesting:!!n.isTesting},we={},Ct="http://www.w3.org/2000/svg",At="http://www.w3.org/1999/xhtml",et=n.hotModuleReplacement?window.__STENCIL_HOSTREFS__||(window.__STENCIL_HOSTREFS__=new WeakMap):new WeakMap,x=e=>et.get(e);var kt=(e,t)=>{let s={$flags$:0,$hostElement$:e,$cmpMeta$:t,$instanceValues$:new Map};n.isDev&&(s.$renderCount$=0),n.method&&n.lazyLoad&&(s.$onInstancePromise$=new Promise(r=>s.$onInstanceResolve$=r)),n.asyncLoading&&(s.$onReadyPromise$=new Promise(r=>s.$onReadyResolve$=r),e["s-p"]=[],e["s-rc"]=[]);let i=et.set(e,s);return!n.lazyLoad&&n.modernPropertyDecls&&(n.state||n.prop)&&Et(e,s),i},Oe=(e,t)=>t in e,Et=(e,t)=>{var s;let i=t.$cmpMeta$;Object.entries((s=i.$members$)!=null?s:{}).map(([o,[a]])=>{if(n.state&&n.prop&&(a&2048)===0&&(a&31||a&32)){let c=e[o],l=Object.getOwnPropertyDescriptor(Object.getPrototypeOf(e),o);Object.defineProperty(e,o,{get(){return l.get.call(this)},set(d){l.set.call(this,d)},configurable:!0,enumerable:!0}),e[o]=t.$instanceValues$.has(o)?t.$instanceValues$.get(o):c}})},wt,N=(e,t)=>(wt||console.error)(e,t),tt=n.isTesting?["STENCIL:"]:["%cstencil","color: white;background:#4c47ff;font-weight: bold; font-size:10px; padding:2px 6px; border-radius: 5px"],V=(...e)=>console.error(...tt,...e),M=(...e)=>console.warn(...tt,...e);var Ne=new Map;var Ot=(e,t,s)=>{let i=e.$tagName$.replace(/-/g,"_"),r=e.$lazyBundleId$;if(n.isDev&&typeof r!="string"){V(`Trying to lazily load component <${e.$tagName$}> with style mode "${t.$modeName$}", but it does not exist.`);return}else if(!r)return;let o=n.hotModuleReplacement?!1:Ne.get(r);if(o)return o[i];return Dt(`./${r}.entry.js${n.hotModuleReplacement&&s?"?s-hmr="+s:""}`).then(a=>(n.hotModuleReplacement||Ne.set(r,a),a[i]),N)},ee=new Map,st=[],Nt="r",Ut="o",Bt="s",Rt="t",jt="c",W="s-id",$e="sty-id",Ue="c-id";var zt="slot-fb{display:contents}slot-fb[hidden]{display:none}",Be="http://www.w3.org/1999/xlink",Pt=["formAssociatedCallback","formResetCallback","formDisabledCallback","formStateRestoreCallback"],H=typeof window<"u"?window:{},S=H.document||{head:{}},Qs=H.HTMLElement||class{},v={$flags$:0,$resourcesUrl$:"",jmp:e=>e(),raf:e=>requestAnimationFrame(e),ael:(e,t,s,i)=>e.addEventListener(t,s,i),rel:(e,t,s,i)=>e.removeEventListener(t,s,i),ce:(e,t)=>new CustomEvent(e,t)},Xs=e=>{Object.assign(v,e)},z=n.shadowDom,Ht=(()=>{let e=!1;try{S.addEventListener("e",null,Object.defineProperty({},"passive",{get(){e=!0}}))}catch{}return e})(),Ft=e=>Promise.resolve(e),nt=n.constructableCSS?(()=>{try{return new CSSStyleSheet,typeof new CSSStyleSheet().replaceSync=="function"}catch{}return!1})():!1,de=0,te=!1,J=[],B=[],fe=[],it=(e,t)=>s=>{e.push(s),te||(te=!0,t&&v.$flags$&4?oe(se):v.raf(se))},Re=e=>{for(let t=0;t<e.length;t++)try{e[t](performance.now())}catch(s){N(s)}e.length=0},je=(e,t)=>{let s=0,i=0;for(;s<e.length&&(i=performance.now())<t;)try{e[s++](i)}catch(r){N(r)}s===e.length?e.length=0:s!==0&&e.splice(0,s)},se=()=>{if(n.asyncQueue&&de++,Re(J),n.asyncQueue){let e=(v.$flags$&6)===2?performance.now()+14*Math.ceil(de*.1):1/0;je(B,e),je(fe,e),B.length>0&&(fe.push(...B),B.length=0),(te=J.length+B.length+fe.length>0)?v.raf(se):de=0}else Re(B),(te=J.length>0)&&v.raf(se)},oe=e=>Ft().then(e),Ks=it(J,!1),Mt=it(B,!0),Gs=e=>{let t=new URL(e,v.$resourcesUrl$);return t.origin!==H.location.origin?t.href:t.pathname};var Wt=e=>e!=null&&e!==void 0,_e=e=>(e=typeof e,e==="object"||e==="function");function qt(e){var t,s,i;return(i=(s=(t=e.head)==null?void 0:t.querySelector('meta[name="csp-nonce"]'))==null?void 0:s.getAttribute("content"))!=null?i:void 0}var Qt={};It(Qt,{err:()=>rt,map:()=>Xt,ok:()=>pe,unwrap:()=>Kt,unwrapErr:()=>Gt});var pe=e=>({isOk:!0,isErr:!1,value:e}),rt=e=>({isOk:!1,isErr:!0,value:e});function Xt(e,t){if(e.isOk){let s=t(e.value);return s instanceof Promise?s.then(i=>pe(i)):pe(s)}if(e.isErr){let s=e.value;return rt(s)}throw"should never get here"}var Kt=e=>{if(e.isOk)return e.value;throw e.value},Gt=e=>{if(e.isErr)return e.value;throw e.value},le=e=>{let t=e.__childNodes||e.childNodes;e.tagName&&e.tagName.includes("-")&&e["s-cr"]&&e.tagName!=="SLOT-FB"&&X(t,e.tagName).forEach(s=>{var i;s.nodeType===1&&s.tagName==="SLOT-FB"&&((i=De(s,s["s-sn"],!1))!=null&&i.length?s.hidden=!0:s.hidden=!1)});for(let s of t)s.nodeType===1&&(s.__childNodes||s.childNodes).length&&le(s)},ve=e=>{let t=[];for(let s=0;s<e.length;s++){let i=e[s]["s-nr"];i&&i.isConnected&&t.push(i)}return t},X=(e,t,s)=>{let i=0,r=[],o;for(;i<e.length;i++){if(o=e[i],o["s-sr"]&&o["s-hn"]===t&&(!s||o["s-sn"]===s)&&(r.push(o),typeof s<"u"))return r;r=[...r,...X(o.childNodes,t,s)]}return r},De=(e,t,s=!0)=>{let i=[];for((s&&e["s-sr"]||!e["s-sr"])&&i.push(e);(e=e.nextSibling)&&e["s-sn"]===t;)i.push(e);return i},ze=(e,t)=>e.nodeType===1?e.getAttribute("slot")===null&&t===""||e.getAttribute("slot")===t:e["s-sn"]===t?!0:t==="",Te=(e,t,s,i)=>{let r;if(e["s-ol"]&&e["s-ol"].isConnected?r=e["s-ol"]:(r=document.createTextNode(""),r["s-nr"]=e),!t["s-cr"]||!t["s-cr"].parentNode)return;let o=t["s-cr"].parentNode,a=s?o.__prepend||o.prepend:o.__appendChild||o.appendChild;if(typeof i<"u"){if(n.hydrateClientSide){r["s-oo"]=i;let c=o.__childNodes||o.childNodes,l=[r];c.forEach(d=>{d["s-nr"]&&l.push(d)}),l.sort((d,$)=>!d["s-oo"]||d["s-oo"]<$["s-oo"]?-1:!$["s-oo"]||$["s-oo"]<d["s-oo"]?1:0),l.forEach(d=>a.call(o,d))}}else a.call(o,r);e["s-ol"]=r,e["s-sh"]=t["s-hn"]},ot=e=>e["s-sn"]||e.nodeType===1&&e.getAttribute("slot")||"",lt=(e,t,...s)=>{let i=null,r=null,o=null,a=!1,c=!1,l=[],d=f=>{for(let h=0;h<f.length;h++)i=f[h],Array.isArray(i)?d(i):i!=null&&typeof i!="boolean"&&((a=typeof e!="function"&&!_e(i))?i=String(i):n.isDev&&typeof e!="function"&&i.$flags$===void 0&&V(`vNode passed as children has unexpected type.
Make sure it's using the correct h() function.
Empty objects can also be the cause, look for JSX comments that became objects.`),a&&c?l[l.length-1].$text$+=i:l.push(a?P(null,i):i),c=a)};if(d(s),t&&(n.isDev&&e==="input"&&Vt(t),n.vdomKey&&t.key&&(r=t.key),n.slotRelocation&&t.name&&(o=t.name),n.vdomClass)){let f=t.className||t.class;f&&(t.class=typeof f!="object"?f:Object.keys(f).filter(h=>f[h]).join(" "))}if(n.isDev&&l.some(ge)&&V(`The <Host> must be the single root component. Make sure:
- You are NOT using hostData() and <Host> in the same component.
- <Host> is used once, and it's the single root component of the render() function.`),n.vdomFunctional&&typeof e=="function")return e(t===null?{}:t,l,Jt);let $=P(e,null);return $.$attrs$=t,l.length>0&&($.$children$=l),n.vdomKey&&($.$key$=r),n.slotRelocation&&($.$name$=o),$},P=(e,t)=>{let s={$flags$:0,$tag$:e,$text$:t,$elm$:null,$children$:null};return n.vdomAttribute&&(s.$attrs$=null),n.vdomKey&&(s.$key$=null),n.slotRelocation&&(s.$name$=null),s},Yt={},ge=e=>e&&e.$tag$===Yt,Jt={forEach:(e,t)=>e.map(Pe).forEach(t),map:(e,t)=>e.map(Pe).map(t).map(Zt)},Pe=e=>({vattrs:e.$attrs$,vchildren:e.$children$,vkey:e.$key$,vname:e.$name$,vtag:e.$tag$,vtext:e.$text$}),Zt=e=>{if(typeof e.vtag=="function"){let s=K({},e.vattrs);return e.vkey&&(s.key=e.vkey),e.vname&&(s.name=e.vname),lt(e.vtag,s,...e.vchildren||[])}let t=P(e.vtag,e.vtext);return t.$attrs$=e.vattrs,t.$children$=e.vchildren,t.$key$=e.vkey,t.$name$=e.vname,t},Vt=e=>{let t=Object.keys(e),s=t.indexOf("value");if(s===-1)return;let i=t.indexOf("type"),r=t.indexOf("min"),o=t.indexOf("max"),a=t.indexOf("step");(s<i||s<r||s<o||s<a)&&M('The "value" prop of <input> should be set after "min", "max", "type" and "step"')},He=(e,t,s,i,r,o)=>{if(s!==i){let a=Oe(e,t),c=t.toLowerCase();if(n.vdomClass&&t==="class"){let l=e.classList,d=Fe(s),$=Fe(i);e["s-si"]?($.push(e["s-si"]),d.forEach(f=>{f.startsWith(e["s-si"])&&$.push(f)}),$=[...new Set($)],l.add(...$),delete e["s-si"]):(l.remove(...d.filter(f=>f&&!$.includes(f))),l.add(...$.filter(f=>f&&!d.includes(f))))}else if(n.vdomStyle&&t==="style"){if(n.updatable)for(let l in s)(!i||i[l]==null)&&(!n.hydrateServerSide&&l.includes("-")?e.style.removeProperty(l):e.style[l]="");for(let l in i)(!s||i[l]!==s[l])&&(!n.hydrateServerSide&&l.includes("-")?e.style.setProperty(l,i[l]):e.style[l]=i[l])}else if(!(n.vdomKey&&t==="key")){if(n.vdomRef&&t==="ref")i&&i(e);else if(n.vdomListener&&(n.lazyLoad?!a:!e.__lookupSetter__(t))&&t[0]==="o"&&t[1]==="n"){if(t[2]==="-"?t=t.slice(3):Oe(H,c)?t=c.slice(2):t=c[2]+t.slice(3),s||i){let l=t.endsWith(at);t=t.replace(ts,""),s&&v.rel(e,t,s,l),i&&v.ael(e,t,i,l)}}else if(n.vdomPropOrAttr){let l=_e(i);if((a||l&&i!==null)&&!r)try{if(e.tagName.includes("-"))e[t]=i;else{let $=i??"";t==="list"?a=!1:(s==null||e[t]!=$)&&(typeof e.__lookupSetter__(t)=="function"?e[t]=$:e.setAttribute(t,$))}}catch{}let d=!1;n.vdomXlink&&c!==(c=c.replace(/^xlink\:?/,""))&&(t=c,d=!0),i==null||i===!1?(i!==!1||e.getAttribute(t)==="")&&(n.vdomXlink&&d?e.removeAttributeNS(Be,t):e.removeAttribute(t)):(!a||o&4||r)&&!l&&(i=i===!0?"":i,n.vdomXlink&&d?e.setAttributeNS(Be,t,i):e.setAttribute(t,i))}}}},es=/\s/,Fe=e=>(typeof e=="object"&&"baseVal"in e&&(e=e.baseVal),e?e.split(es):[]),at="Capture",ts=new RegExp(at+"$"),ct=(e,t,s)=>{let i=t.$elm$.nodeType===11&&t.$elm$.host?t.$elm$.host:t.$elm$,r=e&&e.$attrs$||we,o=t.$attrs$||we;if(n.updatable)for(let a of Me(Object.keys(r)))a in o||He(i,a,r[a],void 0,s,t.$flags$);for(let a of Me(Object.keys(o)))He(i,a,r[a],o[a],s,t.$flags$)};function Me(e){return e.includes("ref")?[...e.filter(t=>t!=="ref"),"ref"]:e}var Z,ne,w,F=!1,ie=!1,ae=!1,D=!1,re=(e,t,s)=>{var i;let r=t.$children$[s],o=0,a,c,l;if(n.slotRelocation&&!F&&(ae=!0,r.$tag$==="slot"&&(r.$flags$|=r.$children$?2:1)),n.isDev&&r.$elm$&&V(`The JSX ${r.$text$!==null?`"${r.$text$}" text`:`"${r.$tag$}" element`} node should not be shared within the same renderer. The renderer caches element lookups in order to improve performance. However, a side effect from this is that the exact same JSX node should not be reused. For more information please see https://stenciljs.com/docs/templating-jsx#avoid-shared-jsx-nodes`),n.vdomText&&r.$text$!==null)a=r.$elm$=S.createTextNode(r.$text$);else if(n.slotRelocation&&r.$flags$&1)a=r.$elm$=n.isDebug||n.hydrateServerSide?ns(r):S.createTextNode("");else{if(n.svg&&!D&&(D=r.$tag$==="svg"),a=r.$elm$=n.svg?S.createElementNS(D?Ct:At,!F&&n.slotRelocation&&r.$flags$&2?"slot-fb":r.$tag$):S.createElement(!F&&n.slotRelocation&&r.$flags$&2?"slot-fb":r.$tag$),n.svg&&D&&r.$tag$==="foreignObject"&&(D=!1),n.vdomAttribute&&ct(null,r,D),n.scoped&&Wt(Z)&&a["s-si"]!==Z&&a.classList.add(a["s-si"]=Z),r.$children$)for(o=0;o<r.$children$.length;++o)c=re(e,r,o),c&&a.appendChild(c);n.svg&&(r.$tag$==="svg"?D=!1:a.tagName==="foreignObject"&&(D=!0))}return a["s-hn"]=w,n.slotRelocation&&r.$flags$&3&&(a["s-sr"]=!0,a["s-cr"]=ne,a["s-sn"]=r.$name$||"",a["s-rf"]=(i=r.$attrs$)==null?void 0:i.ref,l=e&&e.$children$&&e.$children$[s],l&&l.$tag$===r.$tag$&&e.$elm$&&(n.experimentalSlotFixes?$t(e.$elm$):q(e.$elm$,!1)),n.scoped&&pt(ne,a,t.$elm$,e?.$elm$)),a},$t=e=>{v.$flags$|=1;let t=e.closest(w.toLowerCase());if(t!=null){let s=Array.from(t.__childNodes||t.childNodes).find(r=>r["s-cr"]),i=Array.from(e.__childNodes||e.childNodes);for(let r of s?i.reverse():i)r["s-sh"]!=null&&(T(t,r,s??null),r["s-sh"]=void 0,ae=!0)}v.$flags$&=-2},q=(e,t)=>{v.$flags$|=1;let s=Array.from(e.__childNodes||e.childNodes);if(e["s-sr"]&&n.experimentalSlotFixes){let i=e;for(;i=i.nextSibling;)i&&i["s-sn"]===e["s-sn"]&&i["s-sh"]===w&&s.push(i)}for(let i=s.length-1;i>=0;i--){let r=s[i];r["s-hn"]!==w&&r["s-ol"]&&(T(Q(r).parentNode,r,Q(r)),r["s-ol"].remove(),r["s-ol"]=void 0,r["s-sh"]=void 0,ae=!0),t&&q(r,t)}v.$flags$&=-2},dt=(e,t,s,i,r,o)=>{let a=n.slotRelocation&&e["s-cr"]&&e["s-cr"].parentNode||e,c;for(n.shadowDom&&a.shadowRoot&&a.tagName===w&&(a=a.shadowRoot);r<=o;++r)i[r]&&(c=re(null,s,r),c&&(i[r].$elm$=c,T(a,c,n.slotRelocation?Q(t):t)))},ft=(e,t,s)=>{for(let i=t;i<=s;++i){let r=e[i];if(r){let o=r.$elm$;ht(r),o&&(n.slotRelocation&&(ie=!0,o["s-ol"]?o["s-ol"].remove():q(o,!0)),o.remove())}}},ss=(e,t,s,i,r=!1)=>{let o=0,a=0,c=0,l=0,d=t.length-1,$=t[0],f=t[d],h=i.length-1,u=i[0],p=i[h],y,b;for(;o<=d&&a<=h;)if($==null)$=t[++o];else if(f==null)f=t[--d];else if(u==null)u=i[++a];else if(p==null)p=i[--h];else if(Y($,u,r))R($,u,r),$=t[++o],u=i[++a];else if(Y(f,p,r))R(f,p,r),f=t[--d],p=i[--h];else if(Y($,p,r))n.slotRelocation&&($.$tag$==="slot"||p.$tag$==="slot")&&q($.$elm$.parentNode,!1),R($,p,r),T(e,$.$elm$,f.$elm$.nextSibling),$=t[++o],p=i[--h];else if(Y(f,u,r))n.slotRelocation&&($.$tag$==="slot"||p.$tag$==="slot")&&q(f.$elm$.parentNode,!1),R(f,u,r),T(e,f.$elm$,$.$elm$),f=t[--d],u=i[++a];else{if(c=-1,n.vdomKey){for(l=o;l<=d;++l)if(t[l]&&t[l].$key$!==null&&t[l].$key$===u.$key$){c=l;break}}n.vdomKey&&c>=0?(b=t[c],b.$tag$!==u.$tag$?y=re(t&&t[a],s,c):(R(b,u,r),t[c]=void 0,y=b.$elm$),u=i[++a]):(y=re(t&&t[a],s,a),u=i[++a]),y&&(n.slotRelocation?T(Q($.$elm$).parentNode,y,Q($.$elm$)):T($.$elm$.parentNode,y,$.$elm$))}o>d?dt(e,i[h+1]==null?null:i[h+1].$elm$,s,i,a,h):n.updatable&&a>h&&ft(t,o,d)},Y=(e,t,s=!1)=>e.$tag$===t.$tag$?n.slotRelocation&&e.$tag$==="slot"?e.$name$===t.$name$:n.vdomKey&&!s?e.$key$===t.$key$:(s&&!e.$key$&&t.$key$&&(e.$key$=t.$key$),!0):!1,Q=e=>e&&e["s-ol"]||e,R=(e,t,s=!1)=>{let i=t.$elm$=e.$elm$,r=e.$children$,o=t.$children$,a=t.$tag$,c=t.$text$,l;!n.vdomText||c===null?(n.svg&&(D=a==="svg"?!0:a==="foreignObject"?!1:D),(n.vdomAttribute||n.reflect)&&(n.slot&&a==="slot"&&!F?n.experimentalSlotFixes&&e.$name$!==t.$name$&&(t.$elm$["s-sn"]=t.$name$||"",$t(t.$elm$.parentElement)):ct(e,t,D)),n.updatable&&r!==null&&o!==null?ss(i,r,t,o,s):o!==null?(n.updatable&&n.vdomText&&e.$text$!==null&&(i.textContent=""),dt(i,null,t,o,0,o.length-1)):!s&&n.updatable&&r!==null&&ft(r,0,r.length-1),n.svg&&D&&a==="svg"&&(D=!1)):n.vdomText&&n.slotRelocation&&(l=i["s-cr"])?l.parentNode.textContent=c:n.vdomText&&e.$text$!==c&&(i.data=c)},k=[],ut=e=>{let t,s,i,r=e.__childNodes||e.childNodes;for(let o of r){if(o["s-sr"]&&(t=o["s-cr"])&&t.parentNode){s=t.parentNode.__childNodes||t.parentNode.childNodes;let a=o["s-sn"];for(i=s.length-1;i>=0;i--)if(t=s[i],!t["s-cn"]&&!t["s-nr"]&&t["s-hn"]!==o["s-hn"]&&(!n.experimentalSlotFixes||!t["s-sh"]||t["s-sh"]!==o["s-hn"]))if(ze(t,a)){let c=k.find(l=>l.$nodeToRelocate$===t);ie=!0,t["s-sn"]=t["s-sn"]||a,c?(c.$nodeToRelocate$["s-sh"]=o["s-hn"],c.$slotRefNode$=o):(t["s-sh"]=o["s-hn"],k.push({$slotRefNode$:o,$nodeToRelocate$:t})),t["s-sr"]&&k.map(l=>{ze(l.$nodeToRelocate$,t["s-sn"])&&(c=k.find(d=>d.$nodeToRelocate$===t),c&&!l.$slotRefNode$&&(l.$slotRefNode$=c.$slotRefNode$))})}else k.some(c=>c.$nodeToRelocate$===t)||k.push({$nodeToRelocate$:t})}o.nodeType===1&&ut(o)}},ht=e=>{n.vdomRef&&(e.$attrs$&&e.$attrs$.ref&&e.$attrs$.ref(null),e.$children$&&e.$children$.map(ht))},T=(e,t,s)=>(n.scoped&&typeof t["s-sn"]=="string"&&t["s-sr"]&&t["s-cr"]&&pt(t["s-cr"],t,e,t.parentElement),e?.insertBefore(t,s));function pt(e,t,s,i){var r;let o;if(e&&typeof t["s-sn"]=="string"&&t["s-sr"]&&e.parentNode&&e.parentNode["s-sc"]&&(o=t["s-si"]||e.parentNode["s-sc"])){let a=t["s-sn"],c=t["s-hn"];if((r=s.classList)==null||r.add(o+"-s"),i&&i.classList.contains(o+"-s")){let l=(i.__childNodes||i.childNodes)[0],d=!1;for(;l;){if(l["s-sn"]!==a&&l["s-hn"]===c&&l["s-sr"]){d=!0;break}l=l.nextSibling}d||i.classList.remove(o+"-s")}}}var We=(e,t,s=!1)=>{var i,r,o,a,c;let l=e.$hostElement$,d=e.$cmpMeta$,$=e.$vnode$||P(null,null),f=ge(t)?t:lt(null,null,t);if(w=l.tagName,n.isDev&&Array.isArray(t)&&t.some(ge))throw new Error(`The <Host> must be the single root component.
Looks like the render() function of "${w.toLowerCase()}" is returning an array that contains the <Host>.

The render() function should look like this instead:

render() {
  // Do not return an array
  return (
    <Host>{content}</Host>
  );
}
  `);if(n.reflect&&d.$attrsToReflect$&&(f.$attrs$=f.$attrs$||{},d.$attrsToReflect$.map(([h,u])=>f.$attrs$[u]=l[h])),s&&f.$attrs$)for(let h of Object.keys(f.$attrs$))l.hasAttribute(h)&&!["key","ref","style","class"].includes(h)&&(f.$attrs$[h]=l[h]);if(f.$tag$=null,f.$flags$|=4,e.$vnode$=f,f.$elm$=$.$elm$=n.shadowDom&&l.shadowRoot||l,(n.scoped||n.shadowDom)&&(Z=l["s-sc"]),F=z&&(d.$flags$&1)!==0,n.slotRelocation&&(ne=l["s-cr"],ie=!1),R($,f,s),n.slotRelocation){if(v.$flags$|=1,ae){ut(f.$elm$);for(let h of k){let u=h.$nodeToRelocate$;if(!u["s-ol"]){let p=n.isDebug||n.hydrateServerSide?is(u):S.createTextNode("");p["s-nr"]=u,T(u.parentNode,u["s-ol"]=p,u)}}for(let h of k){let u=h.$nodeToRelocate$,p=h.$slotRefNode$;if(p){let y=p.parentNode,b=p.nextSibling;if(!n.hydrateServerSide&&(!n.experimentalSlotFixes||b&&b.nodeType===1)){let _=(i=u["s-ol"])==null?void 0:i.previousSibling;for(;_;){let g=(r=_["s-nr"])!=null?r:null;if(g&&g["s-sn"]===u["s-sn"]&&y===g.parentNode){for(g=g.nextSibling;g===u||g?.["s-sr"];)g=g?.nextSibling;if(!g||!g["s-nr"]){b=g;break}}_=_.previousSibling}}(!b&&y!==u.parentNode||u.nextSibling!==b)&&u!==b&&(!n.experimentalSlotFixes&&!u["s-hn"]&&u["s-ol"]&&(u["s-hn"]=u["s-ol"].parentNode.nodeName),T(y,u,b),u.nodeType===1&&u.tagName!=="SLOT-FB"&&(u.hidden=(o=u["s-ih"])!=null?o:!1)),u&&typeof p["s-rf"]=="function"&&p["s-rf"](u)}else u.nodeType===1&&(s&&(u["s-ih"]=(a=u.hidden)!=null?a:!1),u.hidden=!0)}}ie&&le(f.$elm$),v.$flags$&=-2,k.length=0}if(n.experimentalScopedSlotChanges&&d.$flags$&2){let h=f.$elm$.__childNodes||f.$elm$.childNodes;for(let u of h)u["s-hn"]!==w&&!u["s-sh"]&&(s&&u["s-ih"]==null&&(u["s-ih"]=(c=u.hidden)!=null?c:!1),u.hidden=!0)}ne=void 0},ns=e=>S.createComment(`<slot${e.$name$?' name="'+e.$name$+'"':""}> (host=${w.toLowerCase()})`),is=e=>S.createComment("org-location for "+(e.localName?`<${e.localName}> (host=${e["s-hn"]})`:`[${e.textContent}]`)),rs=e=>{vt(e),gt(e),as(e),ls(e),ds(e),cs(e),$s(e),mt(e),yt(e),os(e)},vt=e=>{let t=e.cloneNode;e.cloneNode=function(s){let i=this,r=n.shadowDom?i.shadowRoot&&z:!1,o=t.call(i,r?s:!1);if(n.slot&&!r&&s){let a=0,c,l,d=["s-id","s-cr","s-lr","s-rc","s-sc","s-p","s-cn","s-sr","s-sn","s-hn","s-ol","s-nr","s-si","s-rf","s-scs"],$=this.__childNodes||this.childNodes;for(;a<$.length;a++)c=$[a]["s-nr"],l=d.every(f=>!$[a][f]),c&&(n.appendChildSlotFix&&o.__appendChild?o.__appendChild(c.cloneNode(!0)):o.appendChild(c.cloneNode(!0))),l&&o.appendChild($[a].cloneNode(!0))}return o}},gt=e=>{e.__appendChild=e.appendChild,e.appendChild=function(t){let s=t["s-sn"]=ot(t),i=X(this.__childNodes||this.childNodes,this.tagName,s)[0];if(i){Te(t,i);let r=De(i,s),o=r[r.length-1],a=T(o.parentNode,t,o.nextSibling);return le(this),a}return this.__appendChild(t)}},os=e=>{e.__removeChild=e.removeChild,e.removeChild=function(t){if(t&&typeof t["s-sn"]<"u"){let s=this.__childNodes||this.childNodes;if(X(s,this.tagName,t["s-sn"])&&t.isConnected){t.remove(),le(this);return}}return this.__removeChild(t)}},ls=e=>{e.__prepend=e.prepend,e.prepend=function(...t){t.forEach(s=>{typeof s=="string"&&(s=this.ownerDocument.createTextNode(s));let i=s["s-sn"]=ot(s),r=this.__childNodes||this.childNodes,o=X(r,this.tagName,i)[0];if(o){Te(s,o,!0);let c=De(o,i)[0];return T(c.parentNode,s,c.nextSibling)}return s.nodeType===1&&s.getAttribute("slot")&&(s.hidden=!0),e.__prepend(s)})}},as=e=>{e.__append=e.append,e.append=function(...t){t.forEach(s=>{typeof s=="string"&&(s=this.ownerDocument.createTextNode(s)),this.appendChild(s)})}},cs=e=>{let t=e.insertAdjacentHTML;e.insertAdjacentHTML=function(s,i){if(s!=="afterbegin"&&s!=="beforeend")return t.call(this,s,i);let r=this.ownerDocument.createElement("_"),o;if(r.innerHTML=i,s==="afterbegin")for(;o=r.firstChild;)this.prepend(o);else if(s==="beforeend")for(;o=r.firstChild;)this.append(o)}},$s=e=>{e.insertAdjacentText=function(t,s){this.insertAdjacentHTML(t,s)}},ds=e=>{let t=e.insertAdjacentElement;e.insertAdjacentElement=function(s,i){return s!=="afterbegin"&&s!=="beforeend"?t.call(this,s,i):s==="afterbegin"?(this.prepend(i),i):(s==="beforeend"&&this.append(i),i)}},mt=e=>{E("textContent",e),Object.defineProperty(e,"textContent",{get:function(){let t="";return(this.__childNodes?this.childNodes:ve(this.childNodes)).forEach(i=>t+=i.textContent||""),t},set:function(t){(this.__childNodes?this.childNodes:ve(this.childNodes)).forEach(i=>{i["s-ol"]&&i["s-ol"].remove(),i.remove()}),this.insertAdjacentHTML("beforeend",t)}})},yt=e=>{class t extends Array{item(i){return this[i]}}E("children",e),Object.defineProperty(e,"children",{get(){return this.childNodes.filter(s=>s.nodeType===1)}}),Object.defineProperty(e,"childElementCount",{get(){return this.children.length}}),E("firstChild",e),Object.defineProperty(e,"firstChild",{get(){return this.childNodes[0]}}),E("lastChild",e),Object.defineProperty(e,"lastChild",{get(){return this.childNodes[this.childNodes.length-1]}}),E("childNodes",e),Object.defineProperty(e,"childNodes",{get(){var s,i;if(!v.$flags$||!((s=x(this))!=null&&s.$flags$)||(v.$flags$&1)===0&&((i=x(this))==null?void 0:i.$flags$)&2){let r=new t,o=ve(this.__childNodes);return r.push(...o),r}return t.from(this.__childNodes)}})},fs=e=>{!e||e.__nextSibling||!globalThis.Node||(us(e),ps(e),e.nodeType===Node.ELEMENT_NODE&&(hs(e),vs(e)))},us=e=>{!e||e.__nextSibling||(E("nextSibling",e),Object.defineProperty(e,"nextSibling",{get:function(){var t;let s=(t=this["s-ol"])==null?void 0:t.parentNode.childNodes,i=s?.indexOf(this);return s&&i>-1?s[i+1]:this.__nextSibling}}))},hs=e=>{!e||e.__nextElementSibling||(E("nextElementSibling",e),Object.defineProperty(e,"nextElementSibling",{get:function(){var t;let s=(t=this["s-ol"])==null?void 0:t.parentNode.children,i=s?.indexOf(this);return s&&i>-1?s[i+1]:this.__nextElementSibling}}))},ps=e=>{!e||e.__previousSibling||(E("previousSibling",e),Object.defineProperty(e,"previousSibling",{get:function(){var t;let s=(t=this["s-ol"])==null?void 0:t.parentNode.childNodes,i=s?.indexOf(this);return s&&i>-1?s[i-1]:this.__previousSibling}}))},vs=e=>{!e||e.__previousElementSibling||(E("previousElementSibling",e),Object.defineProperty(e,"previousElementSibling",{get:function(){var t;let s=(t=this["s-ol"])==null?void 0:t.parentNode.children,i=s?.indexOf(this);return s&&i>-1?s[i-1]:this.__previousElementSibling}}))},gs=["children","nextElementSibling","previousElementSibling"],ms=["childNodes","firstChild","lastChild","nextSibling","previousSibling","textContent"];function E(e,t){let s;gs.includes(e)?s=Object.getOwnPropertyDescriptor(Element.prototype,e):ms.includes(e)&&(s=Object.getOwnPropertyDescriptor(Node.prototype,e)),s||(s=Object.getOwnPropertyDescriptor(t,e)),s&&Object.defineProperty(t,"__"+e,s)}var ys=0,O=(e,t="")=>{if(n.profile&&performance.mark){let s=`st:${e}:${t}:${ys++}`;return performance.mark(s),()=>performance.measure(`[Stencil] ${e}() <${t}>`,s)}else return()=>{}},Ss=(e,t)=>n.profile&&performance.mark?(performance.getEntriesByName(e,"mark").length===0&&performance.mark(e),()=>{performance.getEntriesByName(t,"measure").length===0&&performance.measure(t,e)}):()=>{};var bs=(e,t,s,i)=>{let r=O("hydrateClient",t),o=e.shadowRoot,a=[],c=[],l=[],d=n.shadowDom&&o?[]:null,$=P(t,null);$.$elm$=e;let f;if(n.scoped){let m=i.$cmpMeta$;m&&m.$flags$&10&&e["s-sc"]?(f=e["s-sc"],e.classList.add(f+"-h")):e["s-sc"]&&delete e["s-sc"]}v.$orgLocNodes$||ye(S.body,v.$orgLocNodes$=new Map),e[W]=s,e.removeAttribute(W),i.$vnode$=me($,a,c,d,e,e,s,l);let h=0,u=a.length,p;for(h;h<u;h++){p=a[h];let m=p.$hostId$+"."+p.$nodeId$,C=v.$orgLocNodes$.get(m),A=p.$elm$;o||(A["s-hn"]=t.toUpperCase(),p.$tag$==="slot"&&(A["s-cr"]=e["s-cr"])),p.$tag$==="slot"&&(p.$children$?(p.$flags$|=2,p.$elm$.childNodes.length||p.$children$.forEach(_t=>{p.$elm$.appendChild(_t.$elm$)})):p.$flags$|=1),C&&C.isConnected&&(o&&C["s-en"]===""&&C.parentNode.insertBefore(A,C.nextSibling),C.parentNode.removeChild(C),o||(A["s-oo"]=parseInt(p.$nodeId$))),v.$orgLocNodes$.delete(m)}let y=[],b=l.length,_=0,g,U,Ae,L;for(_;_<b;_++)if(g=l[_],!(!g||!g.length))for(Ae=g.length,U=0,U;U<Ae;U++){if(L=g[U],y[L.hostId]||(y[L.hostId]=v.$orgLocNodes$.get(L.hostId)),!y[L.hostId])continue;let m=y[L.hostId];(!m.shadowRoot||!o)&&(L.slot["s-cr"]=m["s-cr"],!L.slot["s-cr"]&&m.shadowRoot?L.slot["s-cr"]=m:L.slot["s-cr"]=(m.__childNodes||m.childNodes)[0],Te(L.node,L.slot,!1,L.node["s-oo"]),n.experimentalSlotFixes&&fs(L.node)),m.shadowRoot&&L.node.parentElement!==m&&m.appendChild(L.node)}if(n.scoped&&f&&c.length&&c.forEach(m=>{m.$elm$.parentElement.classList.add(f+"-s")}),n.shadowDom&&o){let m=0,C=d.length;for(m;m<C;m++)o.appendChild(d[m]);Array.from(e.childNodes).forEach(A=>{A.nodeType===8&&typeof A["s-sn"]!="string"&&A.parentNode.removeChild(A)})}i.$hostElement$=e,r()},me=(e,t,s,i,r,o,a,c=[])=>{let l,d,$,f,h=r["s-sc"];if(o.nodeType===1){if(l=o.getAttribute(Ue),l&&(d=l.split("."),d[0]===a||d[0]==="0")){$=qe({$flags$:0,$hostId$:d[0],$nodeId$:d[1],$depth$:d[2],$index$:d[3],$tag$:o.tagName.toLowerCase(),$elm$:o,$attrs$:{class:o.className||""}}),t.push($),o.removeAttribute(Ue),e.$children$||(e.$children$=[]),n.scoped&&h&&(o["s-si"]=h,$.$attrs$.class+=" "+h);let p=$.$elm$.getAttribute("s-sn");typeof p=="string"&&($.$tag$==="slot-fb"&&(Qe(p,d[2],$,o,e,t,s,i,c),n.scoped&&h&&o.classList.add(h)),$.$elm$["s-sn"]=p,$.$elm$.removeAttribute("s-sn")),$.$index$!==void 0&&(e.$children$[$.$index$]=$),e=$,i&&$.$depth$==="0"&&(i[$.$index$]=$.$elm$)}if(o.shadowRoot)for(f=o.shadowRoot.childNodes.length-1;f>=0;f--)me(e,t,s,i,r,o.shadowRoot.childNodes[f],a,c);let u=o.__childNodes||o.childNodes;for(f=u.length-1;f>=0;f--)me(e,t,s,i,r,u[f],a,c)}else if(o.nodeType===8){if(d=o.nodeValue.split("."),d[1]===a||d[1]==="0"){if(l=d[0],$=qe({$hostId$:d[1],$nodeId$:d[2],$depth$:d[3],$index$:d[4]||"0",$elm$:o,$attrs$:null,$children$:null,$key$:null,$name$:null,$tag$:null,$text$:null}),l===Rt)$.$elm$=o.nextSibling,$.$elm$&&$.$elm$.nodeType===3&&($.$text$=$.$elm$.textContent,t.push($),o.remove(),a===$.$hostId$&&(e.$children$||(e.$children$=[]),e.$children$[$.$index$]=$),i&&$.$depth$==="0"&&(i[$.$index$]=$.$elm$));else if(l===jt)$.$elm$=o.nextSibling,$.$elm$&&$.$elm$.nodeType===8&&(t.push($),o.remove());else if($.$hostId$===a)if(l===Bt){let u=o["s-sn"]=d[5]||"";Qe(u,d[2],$,o,e,t,s,i,c)}else l===Nt&&(n.shadowDom&&i?o.remove():n.slotRelocation&&(r["s-cr"]=o,o["s-cn"]=!0))}}else if(e&&e.$tag$==="style"){let u=P(null,o.textContent);u.$elm$=o,u.$index$="0",e.$children$=[u]}return e},ye=(e,t)=>{if(e.nodeType===1){let s=e[W]||e.getAttribute(W);s&&t.set(s,e);let i=0;if(e.shadowRoot)for(;i<e.shadowRoot.childNodes.length;i++)ye(e.shadowRoot.childNodes[i],t);let r=e.__childNodes||e.childNodes;for(i=0;i<r.length;i++)ye(r[i],t)}else if(e.nodeType===8){let s=e.nodeValue.split(".");s[0]===Ut&&(t.set(s[1]+"."+s[2],e),e.nodeValue="",e["s-en"]=s[3])}},qe=e=>K(K({},{$flags$:0,$hostId$:null,$nodeId$:null,$depth$:null,$index$:"0",$elm$:null,$attrs$:null,$children$:null,$key$:null,$name$:null,$tag$:null,$text$:null}),e);function Qe(e,t,s,i,r,o,a,c,l){i["s-sr"]=!0,s.$name$=e||null,s.$tag$="slot";let d=r?.$elm$?r.$elm$["s-id"]||r.$elm$.getAttribute("s-id"):"";if(n.shadowDom&&c){let $=s.$elm$=S.createElement(s.$tag$);s.$name$&&s.$elm$.setAttribute("name",e),d&&d!==s.$hostId$?r.$elm$.insertBefore($,r.$elm$.children[0]):i.parentNode.insertBefore(s.$elm$,i),Xe(l,t,e,i,s.$hostId$),i.remove(),s.$depth$==="0"&&(c[s.$index$]=s.$elm$)}else{let $=s.$elm$,f=d&&d!==s.$hostId$&&r.$elm$.shadowRoot;Xe(l,t,e,i,f?d:s.$hostId$),f&&r.$elm$.insertBefore($,r.$elm$.children[0]),o.push(s)}a.push(s),r.$children$||(r.$children$=[]),r.$children$[s.$index$]=s}var Xe=(e,t,s,i,r)=>{let o=i.nextSibling;for(e[t]=e[t]||[];o&&((o.getAttribute&&o.getAttribute("slot")||o["s-sn"])===s||s===""&&!o["s-sn"]&&(o.nodeType===8&&o.nodeValue.indexOf(".")!==1||o.nodeType===3));)o["s-sn"]=s,e[t].push({slot:i,node:o,hostId:r}),o=o.nextSibling},Ls=e=>st.map(t=>t(e)).find(t=>!!t),an=e=>st.push(e),cn=e=>x(e).$modeName$,Se=(e,t)=>e!=null&&!_e(e)?n.propBoolean&&t&4?e==="false"?!1:e===""||!!e:n.propNumber&&t&2?parseFloat(e):n.propString&&t&1?String(e):e:e,xs=e=>n.lazyLoad?x(e).$hostElement$:e,vn=(e,t,s)=>{let i=xs(e);return{emit:r=>(n.isDev&&!i.isConnected&&M(`The "${t}" event was emitted, but the dispatcher node is no longer connected to the dom.`),Ie(i,t,{bubbles:!!(s&4),composed:!!(s&2),cancelable:!!(s&1),detail:r}))}},Ie=(e,t,s)=>{let i=v.ce(t,s);return e.dispatchEvent(i),i},Ke=new WeakMap,_s=(e,t,s)=>{let i=ee.get(e);nt&&s?(i=i||new CSSStyleSheet,typeof i=="string"?i=t:i.replaceSync(t)):i=t,ee.set(e,i)},be=(e,t,s)=>{var i;let r=Ce(t,s),o=ee.get(r);if(!n.attachStyles)return r;if(e=e.nodeType===11?e:S,o)if(typeof o=="string"){e=e.head||e;let a=Ke.get(e),c;if(a||Ke.set(e,a=new Set),!a.has(r)){if(n.hydrateClientSide&&e.host&&(c=e.querySelector(`[${$e}="${r}"]`)))c.innerHTML=o;else{c=document.querySelector(`[${$e}="${r}"]`)||S.createElement("style"),c.innerHTML=o;let l=(i=v.$nonce$)!=null?i:qt(S);if(l!=null&&c.setAttribute("nonce",l),(n.hydrateServerSide||n.hotModuleReplacement)&&t.$flags$&2&&c.setAttribute($e,r),!(t.$flags$&1))if(e.nodeName==="HEAD"){let d=e.querySelectorAll("link[rel=preconnect]"),$=d.length>0?d[d.length-1].nextSibling:e.querySelector("style");e.insertBefore(c,$)}else if("host"in e)if(nt){let d=new CSSStyleSheet;d.replaceSync(o),e.adoptedStyleSheets=[d,...e.adoptedStyleSheets]}else{let d=e.querySelector("style");d?d.innerHTML=o+d.innerHTML:e.prepend(c)}else e.append(c);t.$flags$&1&&e.nodeName!=="HEAD"&&e.insertBefore(c,null)}t.$flags$&4&&(c.innerHTML+=zt),a&&a.add(r)}}else n.constructableCSS&&!e.adoptedStyleSheets.includes(o)&&(e.adoptedStyleSheets=[...e.adoptedStyleSheets,o]);return r},Ds=e=>{let t=e.$cmpMeta$,s=e.$hostElement$,i=t.$flags$,r=O("attachStyles",t.$tagName$),o=be(n.shadowDom&&z&&s.shadowRoot?s.shadowRoot:s.getRootNode(),t,e.$modeName$);(n.shadowDom||n.scoped)&&n.cssAnnotations&&i&10&&i&2&&(s["s-sc"]=o,s.classList.add(o+"-h")),r()},Ce=(e,t)=>"sc-"+(n.mode&&t&&e.$flags$&32?e.$tagName$+"-"+t:e.$tagName$),St=(e,t)=>{n.asyncLoading&&t&&!e.$onRenderResolve$&&t["s-p"]&&t["s-p"].push(new Promise(s=>e.$onRenderResolve$=s))},ce=(e,t)=>{if(n.taskQueue&&n.updatable&&(e.$flags$|=16),n.asyncLoading&&e.$flags$&4){e.$flags$|=512;return}St(e,e.$ancestorComponent$);let s=()=>Ts(e,t);return n.taskQueue?Mt(s):s()},Ts=(e,t)=>{let s=e.$hostElement$,i=O("scheduleUpdate",e.$cmpMeta$.$tagName$),r=n.lazyLoad?e.$lazyInstance$:s;if(!r)throw new Error(`Can't render component <${s.tagName.toLowerCase()} /> with invalid Stencil runtime! Make sure this imported component is compiled with a \`externalRuntime: true\` flag. For more information, please refer to https://stenciljs.com/docs/custom-elements#externalruntime`);let o;return t?(n.lazyLoad&&n.hostListener&&(e.$flags$|=256,e.$queuedListeners$&&(e.$queuedListeners$.map(([a,c])=>I(r,a,c)),e.$queuedListeners$=void 0)),j(s,"componentWillLoad"),n.cmpWillLoad&&(o=I(r,"componentWillLoad"))):(j(s,"componentWillUpdate"),n.cmpWillUpdate&&(o=I(r,"componentWillUpdate"))),j(s,"componentWillRender"),n.cmpWillRender&&(o=Ge(o,()=>I(r,"componentWillRender"))),i(),Ge(o,()=>Cs(e,r,t))},Ge=(e,t)=>Is(e)?e.then(t).catch(s=>{console.error(s),t()}):t(),Is=e=>e instanceof Promise||e&&e.then&&typeof e.then=="function",Cs=async(e,t,s)=>{var i;let r=e.$hostElement$,o=O("update",e.$cmpMeta$.$tagName$),a=r["s-rc"];n.style&&s&&Ds(e);let c=O("render",e.$cmpMeta$.$tagName$);if(n.isDev&&(e.$flags$|=1024),n.hydrateServerSide?await Je(e,t,r,s):Je(e,t,r,s),n.isDev&&(e.$renderCount$=e.$renderCount$===void 0?1:e.$renderCount$+1,e.$flags$&=-1025),n.hydrateServerSide)try{Lt(r),s&&(e.$cmpMeta$.$flags$&1?r["s-en"]="":e.$cmpMeta$.$flags$&2&&(r["s-en"]="c"))}catch(l){N(l,r)}if(n.asyncLoading&&a&&(a.map(l=>l()),r["s-rc"]=void 0),c(),o(),n.asyncLoading){let l=(i=r["s-p"])!=null?i:[],d=()=>Ze(e);l.length===0?d():(Promise.all(l).then(d),e.$flags$|=4,l.length=0)}else Ze(e)},Ye=null,Je=(e,t,s,i)=>{let r=!!n.allRenderFn,o=!!n.lazyLoad,a=!!n.taskQueue,c=!!n.updatable;try{if(Ye=t,t=(r||t.render)&&t.render(),c&&a&&(e.$flags$&=-17),(c||o)&&(e.$flags$|=2),n.hasRenderFn||n.reflect)if(n.vdomRender||n.reflect){if(n.hydrateServerSide)return Promise.resolve(t).then(l=>We(e,l,i));We(e,t,i)}else{let l=s.shadowRoot;e.$cmpMeta$.$flags$&1?l.textContent=t:s.textContent=t}}catch(l){N(l,e.$hostElement$)}return Ye=null,null};var Ze=e=>{let t=e.$cmpMeta$.$tagName$,s=e.$hostElement$,i=O("postUpdate",t),r=n.lazyLoad?e.$lazyInstance$:s,o=e.$ancestorComponent$;n.cmpDidRender&&(n.isDev&&(e.$flags$|=1024),I(r,"componentDidRender"),n.isDev&&(e.$flags$&=-1025)),j(s,"componentDidRender"),e.$flags$&64?(n.cmpDidUpdate&&(n.isDev&&(e.$flags$|=1024),I(r,"componentDidUpdate"),n.isDev&&(e.$flags$&=-1025)),j(s,"componentDidUpdate"),i()):(e.$flags$|=64,n.asyncLoading&&n.cssAnnotations&&bt(s),n.cmpDidLoad&&(n.isDev&&(e.$flags$|=2048),I(r,"componentDidLoad"),n.isDev&&(e.$flags$&=-2049)),j(s,"componentDidLoad"),i(),n.asyncLoading&&(e.$onReadyResolve$(s),o||As(t))),n.method&&n.lazyLoad&&e.$onInstanceResolve$(s),n.asyncLoading&&(e.$onRenderResolve$&&(e.$onRenderResolve$(),e.$onRenderResolve$=void 0),e.$flags$&512&&oe(()=>ce(e,!1)),e.$flags$&=-517)},mn=e=>{if(n.updatable&&(Ee.isBrowser||Ee.isTesting)){let t=x(e),s=t.$hostElement$.isConnected;return s&&(t.$flags$&18)===2&&ce(t,!1),s}return!1},As=e=>{n.cssAnnotations&&bt(S.documentElement),n.asyncQueue&&(v.$flags$|=2),oe(()=>Ie(H,"appload",{detail:{namespace:G}})),n.profile&&performance.measure&&performance.measure(`[Stencil] ${G} initial load (by ${e})`,"st:app:start")},I=(e,t,s)=>{if(e&&e[t])try{return e[t](s)}catch(i){N(i)}},j=(e,t)=>{n.lifecycleDOMEvents&&Ie(e,"stencil_"+t,{bubbles:!0,composed:!0,detail:{namespace:G}})},bt=e=>{var t,s;return n.hydratedClass?e.classList.add((t=n.hydratedSelectorName)!=null?t:"hydrated"):n.hydratedAttribute?e.setAttribute((s=n.hydratedSelectorName)!=null?s:"hydrated",""):void 0},Lt=e=>{let t=e.children;if(t!=null)for(let s=0,i=t.length;s<i;s++){let r=t[s];typeof r.connectedCallback=="function"&&r.connectedCallback(),Lt(r)}},ks=(e,t)=>x(e).$instanceValues$.get(t),ue=(e,t,s,i)=>{let r=x(e);if(n.lazyLoad&&!r)throw new Error(`Couldn't find host element for "${i.$tagName$}" as it is unknown to this Stencil runtime. This usually happens when integrating a 3rd party Stencil component with another Stencil component or application. Please reach out to the maintainers of the 3rd party Stencil component or report this on the Stencil Discord server (https://chat.stenciljs.com) or comment on this similar [GitHub issue](https://github.com/ionic-team/stencil/issues/5457).`);let o=n.lazyLoad?r.$hostElement$:e,a=r.$instanceValues$.get(t),c=r.$flags$,l=n.lazyLoad?r.$lazyInstance$:o;s=Se(s,i.$members$[t][0]);let d=Number.isNaN(a)&&Number.isNaN(s),$=s!==a&&!d;if((!n.lazyLoad||!(c&8)||a===void 0)&&$&&(r.$instanceValues$.set(t,s),n.isDev&&(r.$flags$&1024?M(`The state/prop "${t}" changed during rendering. This can potentially lead to infinite-loops and other bugs.`,`
Element`,o,`
New value`,s,`
Old value`,a):r.$flags$&2048&&M(`The state/prop "${t}" changed during "componentDidLoad()", this triggers extra re-renders, try to setup on "componentWillLoad()"`,`
Element`,o,`
New value`,s,`
Old value`,a)),!n.lazyLoad||l)){if(n.watchCallback&&i.$watchers$&&c&128){let f=i.$watchers$[t];f&&f.map(h=>{try{l[h](s,a,t)}catch(u){N(u,o)}})}if(n.updatable&&(c&18)===2){if(n.cmpShouldUpdate&&l.componentShouldUpdate&&l.componentShouldUpdate(s,a,t)===!1)return;ce(r,!1)}}},xt=(e,t,s)=>{var i,r;let o=e.prototype;if(n.formAssociated&&t.$flags$&64&&s&1&&Pt.forEach(a=>{let c=o[a];Object.defineProperty(o,a,{value(...l){let d=x(this),$=n.lazyLoad?d.$lazyInstance$:this;if(!$)d.$onReadyPromise$.then(f=>{let h=f[a];typeof h=="function"&&h.call(f,...l)});else{let f=n.lazyLoad?$[a]:c;typeof f=="function"&&f.call($,...l)}}})}),n.member&&t.$members$||n.watchCallback&&(t.$watchers$||e.watchers)){n.watchCallback&&e.watchers&&!t.$watchers$&&(t.$watchers$=e.watchers);let a=Object.entries((i=t.$members$)!=null?i:{});if(a.map(([c,[l]])=>{if((n.prop||n.state)&&(l&31||(!n.lazyLoad||s&2)&&l&32)){if((l&2048)===0)Object.defineProperty(o,c,{get(){return ks(this,c)},set(d){if(n.isDev){let $=x(this);(s&1)===0&&($&&$.$flags$&8)===0&&(l&31)!==0&&(l&1024)===0&&M(`@Prop() "${c}" on <${t.$tagName$}> is immutable but was modified from within the component.
More information: https://stenciljs.com/docs/properties#prop-mutability`)}ue(this,c,d,t)},configurable:!0,enumerable:!0});else if(s&1&&l&2048&&(n.lazyLoad&&Object.defineProperty(o,c,{get(){let d=x(this),$=n.lazyLoad&&d?d.$lazyInstance$:o;if($)return $[c]},configurable:!0,enumerable:!0}),l&4096)){let d=Object.getOwnPropertyDescriptor(o,c).set;Object.defineProperty(o,c,{set($){let f=x(this);if(d){let u=f.$hostElement$[c];!f.$instanceValues$.get(c)&&u&&f.$instanceValues$.set(c,u),d.apply(this,[Se($,t.$members$[c][0])]),ue(this,c,f.$hostElement$[c],t);return}if(!f)return;let h=()=>{let u=f.$lazyInstance$[c];!f.$instanceValues$.get(c)&&u&&f.$instanceValues$.set(c,u),f.$lazyInstance$[c]=Se($,t.$members$[c][0]),ue(this,c,f.$lazyInstance$[c],t)};f.$lazyInstance$?h():f.$onReadyPromise$.then(()=>h())}})}}else n.lazyLoad&&n.method&&s&1&&l&64&&Object.defineProperty(o,c,{value(...d){var $;let f=x(this);return($=f?.$onInstancePromise$)==null?void 0:$.then(()=>{var h;return(h=f.$lazyInstance$)==null?void 0:h[c](...d)})}})}),n.observeAttribute&&(!n.lazyLoad||s&1)){let c=new Map;o.attributeChangedCallback=function(l,d,$){v.jmp(()=>{var f;let h=c.get(l);if(this.hasOwnProperty(h)&&n.lazyLoad)$=this[h],delete this[h];else{if(o.hasOwnProperty(h)&&typeof this[h]=="number"&&this[h]==$)return;if(h==null){let p=x(this),y=p?.$flags$;if(y&&!(y&8)&&y&128&&$!==d){let b=n.lazyLoad?p.$hostElement$:this,_=n.lazyLoad?p.$lazyInstance$:b,g=(f=t.$watchers$)==null?void 0:f[l];g?.forEach(U=>{_[U]!=null&&_[U].call(_,$,d,l)})}return}}let u=Object.getOwnPropertyDescriptor(o,h);(!u.get||u.set)&&(this[h]=$===null&&typeof this[h]=="boolean"?!1:$)})},e.observedAttributes=Array.from(new Set([...Object.keys((r=t.$watchers$)!=null?r:{}),...a.filter(([l,d])=>d[0]&15).map(([l,d])=>{var $;let f=d[1]||l;return c.set(f,l),n.reflect&&d[0]&512&&(($=t.$attrsToReflect$)==null||$.push([l,f])),f})]))}}return e},Ve=async(e,t,s,i)=>{let r;if((t.$flags$&32)===0){t.$flags$|=32;let c=s.$lazyBundleId$;if((n.lazyLoad||n.hydrateClientSide)&&c){let l=Ot(s,t,i);if(l&&"then"in l){let $=Ss(`st:load:${s.$tagName$}:${t.$modeName$}`,`[Stencil] Load module for <${s.$tagName$}>`);r=await l,$()}else r=l;if(!r)throw new Error(`Constructor for "${s.$tagName$}#${t.$modeName$}" was not found`);n.member&&!r.isProxied&&(n.watchCallback&&(s.$watchers$=r.watchers),xt(r,s,2),r.isProxied=!0);let d=O("createInstance",s.$tagName$);n.member&&(t.$flags$|=8);try{new r(t)}catch($){N($)}n.member&&(t.$flags$&=-9),n.watchCallback&&(t.$flags$|=128),d(),Le(t.$lazyInstance$)}else{r=e.constructor;let l=e.localName;customElements.whenDefined(l).then(()=>t.$flags$|=128)}if(n.style&&r&&r.style){let l;typeof r.style=="string"?l=r.style:n.mode&&typeof r.style!="string"&&(t.$modeName$=Ls(e),t.$modeName$&&(l=r.style[t.$modeName$]),n.hydrateServerSide&&t.$modeName$&&e.setAttribute("s-mode",t.$modeName$));let d=Ce(s,t.$modeName$);if(!ee.has(d)){let $=O("registerStyles",s.$tagName$);!n.hydrateServerSide&&n.shadowDom&&n.shadowDomShim&&s.$flags$&8&&(l=await import("./chunk-PIVURODD.js").then(f=>f.scopeCss(l,d))),_s(d,l,!!(s.$flags$&1)),$()}}}let o=t.$ancestorComponent$,a=()=>ce(t,!0);n.asyncLoading&&o&&o["s-rc"]?o["s-rc"].push(a):a()},Le=e=>{n.lazyLoad&&n.connectedCallback&&I(e,"connectedCallback")},Es=e=>{if((v.$flags$&1)===0){let t=x(e),s=t.$cmpMeta$,i=O("connectedCallback",s.$tagName$);if(n.hostListenerTargetParent&&xe(e,t,s.$listeners$,!0),t.$flags$&1)xe(e,t,s.$listeners$,!1),t?.$lazyInstance$?Le(t.$lazyInstance$):t?.$onReadyPromise$&&t.$onReadyPromise$.then(()=>Le(t.$lazyInstance$));else{t.$flags$|=1;let r;if(n.hydrateClientSide&&(r=e.getAttribute(W),r)){if(n.shadowDom&&z&&s.$flags$&1){let o=n.mode?be(e.shadowRoot,s,e.getAttribute("s-mode")):be(e.shadowRoot,s);e.classList.remove(o+"-h",o+"-s")}else if(n.scoped&&s.$flags$&2){let o=Ce(s,n.mode?e.getAttribute("s-mode"):void 0);e["s-sc"]=o}bs(e,s.$tagName$,r,t)}if(n.slotRelocation&&!r&&(n.hydrateServerSide||(n.slot||n.shadowDom)&&s.$flags$&12)&&ws(e),n.asyncLoading){let o=e;for(;o=o.parentNode||o.host;)if(n.hydrateClientSide&&o.nodeType===1&&o.hasAttribute("s-id")&&o["s-p"]||o["s-p"]){St(t,t.$ancestorComponent$=o);break}}n.prop&&!n.hydrateServerSide&&s.$members$&&Object.entries(s.$members$).map(([o,[a]])=>{if(a&31&&e.hasOwnProperty(o)){let c=e[o];delete e[o],e[o]=c}}),n.initializeNextTick?oe(()=>Ve(e,t,s)):Ve(e,t,s)}i()}},ws=e=>{let t=e["s-cr"]=S.createComment(n.isDebug?`content-ref (host=${e.localName})`:"");t["s-cn"]=!0,T(e,t,e.firstChild)},he=e=>{n.lazyLoad&&n.disconnectedCallback&&I(e,"disconnectedCallback"),n.cmpDidUnload&&I(e,"componentDidUnload")},Os=async e=>{if((v.$flags$&1)===0){let t=x(e);n.hostListener&&t.$rmListeners$&&(t.$rmListeners$.map(s=>s()),t.$rmListeners$=void 0),n.lazyLoad?t?.$lazyInstance$?he(t.$lazyInstance$):t?.$onReadyPromise$&&t.$onReadyPromise$.then(()=>he(t.$lazyInstance$)):he(e)}};var Sn=(e,t)=>{let s={$flags$:t[0],$tagName$:t[1]};n.member&&(s.$members$=t[2]),n.hostListener&&(s.$listeners$=t[3]),n.watchCallback&&(s.$watchers$=e.$watchers$),n.reflect&&(s.$attrsToReflect$=[]),n.shadowDom&&!z&&s.$flags$&1&&(s.$flags$|=8),n.experimentalSlotFixes?n.scoped&&s.$flags$&2&&rs(e.prototype):(n.slotChildNodesFix&&yt(e.prototype),n.cloneNodeFix&&vt(e.prototype),n.appendChildSlotFix&&gt(e.prototype),n.scopedSlotTextContentFix&&s.$flags$&2&&mt(e.prototype));let i=e.prototype.connectedCallback,r=e.prototype.disconnectedCallback;return Object.assign(e.prototype,{__hasHostListenerAttached:!1,__registerHost(){kt(this,s)},connectedCallback(){if(!this.__hasHostListenerAttached){let o=x(this);xe(this,o,s.$listeners$,!1),this.__hasHostListenerAttached=!0}Es(this),n.connectedCallback&&i&&i.call(this)},disconnectedCallback(){Os(this),n.disconnectedCallback&&r&&r.call(this)},__attachShadow(){if(z){if(!this.shadowRoot)n.shadowDelegatesFocus?this.attachShadow({mode:"open",delegatesFocus:!!(s.$flags$&16)}):this.attachShadow({mode:"open"});else if(this.shadowRoot.mode!=="open")throw new Error(`Unable to re-use existing shadow root for ${s.$tagName$}! Mode is set to ${this.shadowRoot.mode} but Stencil only supports open shadow roots.`)}else this.shadowRoot=this}}),e.is=s.$tagName$,xt(e,s,3)};var xe=(e,t,s,i)=>{n.hostListener&&s&&(n.hostListenerTargetParent&&(i?s=s.filter(([r])=>r&32):s=s.filter(([r])=>!(r&32))),s.map(([r,o,a])=>{let c=n.hostListenerTarget?Us(e,r):e,l=Ns(t,a),d=Bs(r);v.ael(c,o,l,d),(t.$rmListeners$=t.$rmListeners$||[]).push(()=>v.rel(c,o,l,d))}))},Ns=(e,t)=>s=>{var i;try{n.lazyLoad?e.$flags$&256?(i=e.$lazyInstance$)==null||i[t](s):(e.$queuedListeners$=e.$queuedListeners$||[]).push([t,s]):e.$hostElement$[t](s)}catch(r){N(r)}},Us=(e,t)=>n.hostListenerTargetDocument&&t&4?S:n.hostListenerTargetWindow&&t&8?H:n.hostListenerTargetBody&&t&16?S.body:n.hostListenerTargetParent&&t&32&&e.parentElement?e.parentElement:e,Bs=e=>Ht?{passive:(e&1)!==0,capture:(e&2)!==0}:(e&2)!==0;export{Ee as a,Qs as b,Xs as c,Ks as d,Mt as e,Gs as f,lt as g,Yt as h,an as i,cn as j,vn as k,mn as l,Sn as m};
