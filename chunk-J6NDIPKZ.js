import{a as u}from"./chunk-426OJ4HC.js";import{a as X}from"./chunk-MM5QLNJM.js";import{b as _}from"./chunk-H3GX5QFY.js";import{e as v}from"./chunk-2EHRGQPU.js";import{b as y}from"./chunk-MCRJI3T3.js";import{c as A}from"./chunk-KUPZ3H4M.js";var I=t=>u().duration(t?400:300),P=t=>{let o,r,c=t.width+8,a=u(),f=u();t.isEndSide?(o=c+"px",r="0px"):(o=-c+"px",r="0px"),a.addElement(t.menuInnerEl).fromTo("transform",`translateX(${o})`,`translateX(${r})`);let m=A(t)==="ios",b=m?.2:.25;return f.addElement(t.backdropEl).fromTo("opacity",.01,b),I(m).addAnimation([a,f])},q=t=>{let o,r,c=A(t),a=t.width;t.isEndSide?(o=-a+"px",r=a+"px"):(o=a+"px",r=-a+"px");let f=u().addElement(t.menuInnerEl).fromTo("transform",`translateX(${r})`,"translateX(0px)"),w=u().addElement(t.contentEl).fromTo("transform","translateX(0px)",`translateX(${o})`),m=u().addElement(t.backdropEl).fromTo("opacity",.01,.32);return I(c==="ios").addAnimation([f,w,m])},U=t=>{let o=A(t),r=t.width*(t.isEndSide?-1:1)+"px",c=u().addElement(t.contentEl).fromTo("transform","translateX(0px)",`translateX(${r})`);return I(o==="ios").addAnimation(c)},D=()=>{let t=new Map,o=[],r=async n=>{let e=await l(n,!0);return e?e.open():!1},c=async n=>{let e=await(n!==void 0?l(n,!0):h());return e!==void 0?e.close():!1},a=async n=>{let e=await l(n,!0);return e?e.toggle():!1},f=async(n,e)=>{let s=await l(e);return s&&(s.disabled=!n),s},w=async(n,e)=>{let s=await l(e);return s&&(s.swipeGesture=n),s},m=async n=>{if(n!=null){let e=await l(n);return e!==void 0&&e.isOpen()}else return await h()!==void 0},b=async n=>{let e=await l(n);return e?!e.disabled:!1},l=async(n,e=!1)=>{if(await g(),n==="start"||n==="end"){let i=o.filter(d=>d.side===n&&!d.disabled);if(i.length>=1)return i.length>1&&e&&X(`menuController queried for a menu on the "${n}" side, but ${i.length} menus were found. The first menu reference will be used. If this is not the behavior you want then pass the ID of the menu instead of its side.`,i.map(d=>d.el)),i[0].el;let p=o.filter(d=>d.side===n);if(p.length>=1)return p.length>1&&e&&X(`menuController queried for a menu on the "${n}" side, but ${p.length} menus were found. The first menu reference will be used. If this is not the behavior you want then pass the ID of the menu instead of its side.`,p.map(d=>d.el)),p[0].el}else if(n!=null)return O(i=>i.menuId===n);let s=O(i=>!i.disabled);return s||(o.length>0?o[0].el:void 0)},h=async()=>(await g(),x()),$=async()=>(await g(),B()),M=async()=>(await g(),T()),E=(n,e)=>{t.set(n,e)},R=n=>{o.indexOf(n)<0&&o.push(n)},C=n=>{let e=o.indexOf(n);e>-1&&o.splice(e,1)},S=async(n,e,s)=>{if(T())return!1;if(e){let i=await h();i&&n.el!==i&&await i.setOpen(!1,!1)}return n._setOpen(e,s)},k=(n,e)=>{let s=t.get(n);if(!s)throw new Error("animation not registered");return s(e)},x=()=>O(n=>n._isOpen),B=()=>o.map(n=>n.el),T=()=>o.some(n=>n.isAnimating),O=n=>{let e=o.find(n);if(e!==void 0)return e.el},g=()=>Promise.all(Array.from(document.querySelectorAll("ion-menu")).map(n=>new Promise(e=>_(n,e))));return E("reveal",U),E("push",q),E("overlay",P),y===null||y===void 0||y.addEventListener("ionBackButton",n=>{let e=x();e&&n.detail.register(v,()=>e.close())}),{registerAnimation:E,get:l,getMenus:$,getOpen:h,isEnabled:b,swipeGesture:w,isAnimating:M,isOpen:m,enable:f,toggle:a,close:c,open:r,_getOpenSync:x,_createAnimation:k,_register:R,_unregister:C,_setOpen:S}},j=D();export{j as a};
